# -*- sh -*-
# This file can be included with #SCRIPTSCOMMON#


# ===== Dumping and reloading using LDIF files =========================  {{{
#
# If incompatible changes are done to the database underlying a LDAP 
# directory we need to dump the contents and reload the data into a newly
# created database after the new server was installed. The following
# functions deal with this functionality.


# ----- Configuration of this component --------------------------------  {{{
#
# Dumping the database can have negative effects on the system we are
# running on. If there is a lot of data dumping it might fill a partition
# for example. Therefore we must give the user exact control over what we
# are doing.

database_dumping_enabled() {						# {{{
# Check if the user has enabled database dumping for the current situation.
# Return success if yes.
# Usage: if database_dumping_enabled; then ... fi

	db_get slapd/dump_database
	case "$RET" in
	always)
		;;
	"when needed")
		database_format_changed || return 1
		;;
	never)
		return 1
		;;
	*)
		echo >&2 "Unknown value for slapd/dump_database: $RET"
		echo >&2 "Please report!"
		exit 1
		;;
	esac
}

# }}}
database_format_changed() {						# {{{
# Check if the database format has changed since the old installed version
# Return success if yes.
# Usage: if database_format_changed; then

	if dpkg --compare-versions "$OLD_VERSION" lt-nl 2.4.7; then
		return 0
	else
		return 1
	fi
}

# }}}
database_dumping_destdir() {						# {{{
# Figure out the directory we are dumping the database to and create it
# if it does not exist.
# Usage: destdir=`database_dumping_destdir`

	local dir
	db_get slapd/dump_database_destdir
	dir=`echo "$RET"|sed -e "s/VERSION/$OLD_VERSION/"`
	mkdir -p -m 700 "$dir"
	echo $dir
}

# }}}
create_new_user() { # {{{
	if [ -z "`getent group openldap`" ]; then
		addgroup --quiet --system openldap
	fi
	if [ -z "`getent passwd openldap`" ]; then
		echo -n "  Creating new user openldap... " >&2
		adduser --quiet --system --home /var/lib/ldap --shell /bin/false \
        --ingroup openldap --disabled-password --disabled-login \
        --gecos "OpenLDAP Server Account" openldap
		echo "done." >&2
	fi
}
# }}}
create_ldap_directories() {	# {{{
	if [ ! -d /var/lib/ldap ]; then
		mkdir -m 0700 /var/lib/ldap
	fi
	if [ ! -d /var/run/slapd ]; then
		mkdir -m 0755 /var/run/slapd
	fi
	update_permissions /var/lib/ldap
	update_permissions /var/run/slapd
}
# }}}
update_permissions() {	# {{{
	dir="$1"
	if [ -d "$dir" ]; then
		[ -z "$SLAPD_USER" ] || chown -R "$SLAPD_USER" "$dir"
		[ -z "$SLAPD_GROUP" ] || chgrp -R "$SLAPD_GROUP" "$dir"
	fi
}
# }}}
update_databases_permissions() {	# {{{
	parse_configuration_file
	for db in `get_database_list`; do
		dbdir=`get_directory $db`
		update_permissions "$dbdir"
		chmod 0700 "$dbdir"
	done
}
# }}}
update_slapd_conf_permissions() {	# {{{
	if [ -n "$SLAPD_USER" ] && [ -n "$SLAPD_GROUP" ] ; then
		if perl -e '
			($o, $m) = (stat $ARGV[0])[4,2];
			exit 1 unless defined $o;
			exit 0 if ($o == 0 && ($m & 040) == 0);
			exit 1;
		' "$SLAPD_CONF"; then
			chgrp "$SLAPD_GROUP" "$SLAPD_CONF"
			chmod g+r "$SLAPD_CONF"
		fi
	fi
}
# }}}
# }}}
# ----- Dumping and loading the data ------------------------------------ {{{

dump_databases() {							# {{{
# If the user wants us to dump the databases they are dumped to the 
# configured directory.
	
	local db suffix file dir failed

	database_dumping_enabled || return 0

	dir=`database_dumping_destdir`
	echo >&2 "  Dumping to $dir: "
	parse_configuration_file
	for db in `get_database_list`; do
		suffix=`get_suffix $db`
		file="$dir/$suffix.ldif"
		echo -n "  - directory $suffix... " >&2
		slapcat -b "$suffix" > "$file" || failed=1
		if [ "$failed" ]; then
			rm -f "$file"
			echo failed. >&2
			exit 1
		fi
		echo "done." >&2
	done
}

# }}}
load_databases() {							# {{{
	local dir file db dbdir backupdir

	dir=`database_dumping_destdir`
	echo >&2 "  Loading from $dir: "
	parse_configuration_file
	for db in `get_database_list`; do
		suffix=`get_suffix $db`
		dbdir=`get_directory $db`
		if ! is_empty_dir "$dbdir"; then
			echo >&2 \
			  "  Directory $dbdir for $suffix not empty, aborting."
			exit 1
		fi

		file="$dir/$suffix.ldif"
		echo -n "  - directory $suffix... " >&2

		# If there is an old DB_CONFIG file, restore it before
		# running slapadd
		backupdir=`compute_backup_path -n "$dbdir" "$suffix"`
		if [ -e "$backupdir"/DB_CONFIG ]; then
			cp -a "$backupdir"/DB_CONFIG "$dbdir"/
		else
			copy_example_DB_CONFIG "$dbdir"/
		fi

		capture_diagnostics slapadd -q -b "$suffix" -l "$file" \
			|| failed=1
		if [ "$failed" ]; then
			rm -f "$dbdir"/*
			echo failed. >&2
			echo >&2
			cat <<-EOF
	Loading the database from the LDIF dump failed with the following
	error while running slapadd:
EOF
			release_diagnostics "    "
			exit 1
		fi
		echo "done." >&2

		if [ -n "$SLAPD_USER" ] || [ -n "$SLAPD_GROUP" ]; then
			echo -n "  - chowning database directory ($SLAPD_USER:$SLAPD_GROUP)... "
			[ -z "$SLAPD_USER" ] || \
				chown -R "$SLAPD_USER" "$dbdir"
			[ -z "$SLAPD_GROUP" ] || \
				chgrp -R "$SLAPD_GROUP" "$dbdir"
			echo "done";
		fi
	done
}

# }}}
move_incompatible_databases_away() {					# {{{
	echo >&2 "  Moving old database directories to /var/backups:"
	parse_configuration_file
	for db in `get_database_list`; do
		suffix=`get_suffix $db`
		dbdir=`get_directory $db`
		move_old_database_away "$dbdir" "$suffix"
	done
}

# }}}
# }}}
# }}}

# ===== Parsing the slapd configuration file ============================ {{{
#
# For some operations we have to know the slapd configuration. These 
# functions are for parsing the slapd configuration file.

merge_logical_lines() {							# {{{
# slapd supports continuation lines in the slapd.conf. Continuation lines 
# start with spaces and are merged with the preceding line. This function
# uses perl to merge physical lines into logical lines as seen by the 
# slapd config parser.
# Usage: merge_logical_lines < input > output

	perl -pe 'BEGIN { undef $/ }; s/\n(?!\n)\s+/ /g;' 
}

# }}}
read_slapd_conf() {							# {{{
# read slapd.conf file and evaluate include statements
# FIXME: circular loops will cause this to block forever
	merge_logical_lines | while read command data; do
		if [ "$command" = "include" ]; then
			file=`eval echo $data`
			read_slapd_conf < $file
		else
			echo $command $data
		fi
	done
}

# }}}
write_slapd_conf() {            # {{{
# Change a configuration setting in a configuration file, follow includes.
# Usage: write_slapd_conf configuration_file regexpression
# FIXME: circular loops will cause this to block forever

	conf=$1
	reg=$2

	# Perl script to change configuration files.
	script='
		use File::Temp;
		use File::Compare;
		use File::Copy;

		sub changeConfig {
			my ($conf, $regexp) = @_;
			my ($fh, $name) = mkstemp("/tmp/tmp.XXXXXX");

			open(HANDLE, "<". $conf) || return;
			my @data = <HANDLE>;
			close(HANDLE);

			foreach $line (@data) {

				# Parse includes, but forget the schema files.
				if ($line =~ /^include/ && $line !~ /\/etc\/ldap\/schema\//) {
					my @file = split(/\s+/, $line);
					changeConfig($file[1], $regexp);
				}

				# Modify the config with the given regexpression.
				$doit = "\$line =~ $regexp";
				eval $doit;
				print $fh $line;
			}

			# Close the tempfile handle opened by mkstemp.
			close($fh);

			# If file is changed by the regexp replace the original file.
			if (compare($conf, $name) != 0) {
				move($name, $conf);
			} else {
				unlink($name);
			}
		}

		$config = shift;
		$regexp = shift;
		changeConfig($config, $regexp);'

	# Use perl to execute the function above.
	perl -e "$script" $conf $reg
}
# }}}
write_database_info() {							# {{{
# Print out the information about one database
# Usage: write_database_info <backend> <suffix> <directory>

	local backend suffix directory
	backend=$1
	suffix=$2
	directory=$3

	if upgrade_supported_from_backend "$backend"; then
    		# If no directory was given use the compiled in value
    		if [ -z "$directory" ]; then
      			directory=/var/lib/ldap
		fi
		echo "$backend"
		echo "$suffix"
		echo "$directory"
  	fi
}

# }}}
parse_configuration_file() {						# {{{
# Get the list of configured databases from the slapd configuration file
# Usage: for db in `get_database_list`; do ... done

	# Create a temporary file with our data
	local infofile
	infofile=`mktemp`
	exec 9<>"$infofile"
	rm "$infofile"

	# Read config and put information into the temp file
	(read_slapd_conf < $SLAPD_CONF && echo database) | \
    	while read command data; do
      		case "$command" in
      		database)
        		# Write information about previous database section 
			# if any
        		if [ -n "$backend" ] && [ -n "$suffix" ]; then
	  			write_database_info >&9 \
					"$backend" "$suffix" "$directory"
			fi
			backend=$data
			suffix=""
			directory=""
        		;;
      		suffix)
        		suffix=`eval echo $data`
		        ;;
	      	directory)
		        directory=`eval echo $data`
        		;;
      		esac
    	done
}

# }}}
read_database_info() {							# {{{
	local script
	script='
		seek STDIN, 0, 0;
		@data = <STDIN>;
		print $data[3 * $ARGV[0] + $ARGV[1]];'
	
	perl <&9 -e "$script" "$@"
}

# }}}
get_backend() { 
	read_database_info "$1" 0 
}
get_suffix() { 
	read_database_info "$1" 1 
}
get_directory() { 
	read_database_info "$1" 2 
}
get_database_list() {
	local script
	script='
		seek STDIN, 0, 0;
		@data = <STDIN>;
		print join(" ", 0..(@data/3 - 1));'
	
	perl <&9 -e "$script" 
}

# }}}

migrate_checkpoint_and_slurpd() {					# {{{
# move any 'checkpoint' options from the backend stanza to the
# per-database stanza, and translate slurpd "replica" options into
# syncrepl defaults

	local script
	script='
		use File::Temp;
		use File::Compare;
		use File::Copy;

		$has_replica = 0;
		$backend_bdb = $backend_hdb = 0;
		$in_bdb = $in_hdb = 0;
		$checkpoint_bdb = "";
		$checkpoint_hdb = "";

		sub changeConfig
		{
			my ($filename) = @_;

			open(HANDLE, "<". $filename) || return;
			my @data = <HANDLE>;
			close(HANDLE);

			my ($fh, $tmpfile) = mkstemp("/tmp/slapd.XXXXXX");

			foreach (@data) {
				# Parse includes, but forget the schema files.
				if (/^include\s+([^\s#]+)/) {
					my $file = $1;
					if ($file !~ m,/etc/ldap/schema/,) {
						changeConfig($file) 
					}
				}
				$backend_bdb = $backend_hdb = 0 if (/^(backend|database)\s+/);
				$backend_bdb = 1 if (/^backend\s+bdb/);
				$backend_hdb = 1 if (/^backend\s+hdb/);
				if (/^checkpoint\s+/) {
					$checkpoint_bdb = $_ if ($backend_bdb || $in_bdb);
					$checkpoint_hdb = $_ if ($backend_hdb || $in_bdb);
					next if ($backend_bdb || $backend_hdb || $in_bdb || $in_hdb);
				}
				$in_bdb = 1 if /^database\s+bdb/;
				$in_hdb = 1 if /^database\s+hdb/;
				if (/^suffix/ && $in_bdb)
				{
					$in_bdb = 0;
					print $fh $_ . $checkpoint_bdb;
					next;
				}
				if (/^suffix/ && $in_hdb)
				{
					$in_hdb = 0;
					print $fh $_ . $checkpoint_hdb;
					next;
				}
				if (/^replica\s+/)
				{
					print $fh "overlay syncprov\n";
					print $fh "syncprov-checkpoint 100 10\n";
					$has_replica = 1;
				}
				print $fh $_;
			}

			# Close the tempfile handle opened by mkstemp.
			close($fh);

			# If file is changed replace the original file.
			if (compare($filename, $tmpfile) != 0) {
				move($tmpfile, $filename);
			} else {
				unlink($tmpfile);
			}
		}

		$config = shift;
		changeConfig ($config);
		exit $has_replica;'

	echo -n "  Upgrading BDB 'checkpoint' options... " >&2

	if perl -e "$script" $SLAPD_CONF ; then
		result=0
	else
		result=1
	fi

	if [ $result -eq 1 ] \
	   && ! grep -q '^moduleload[[:space:]]\+syncprov' $SLAPD_CONF
	then
		# Create a temporary file for the new config
		new_conf=`mktemp -q ${SLAPD_CONF}.XXXXXX`

		# Prepend the module load command
		echo '# load syncrepl provider support, replacing slurpd' > $new_conf
		echo 'moduleload syncprov' >> $new_conf
		echo >> $new_conf
		cat $SLAPD_CONF >> $new_conf

		# Activate the new configuration file
		install_new_slapd_conf "$new_conf"
	fi

	echo . >&2

	return $result
}
# }}}

disable_openssl_cipher_suite() {					# {{{
# disable any occurrences of the TLSCipherSuite on upgrade, because 
# OpenSSL cipher suite specs are completely incompatible with GnuTLS ones

	# If $SLAPD_CONF is a directory, the user is using cn=config.  Assume
	# they know what they're doing.
	if [ -d "$SLAPD_CONF" ]; then return 0; fi

	# Check if there's anything for us to do
	if ! read_slapd_conf < $SLAPD_CONF | \
			grep -q -E '^TLSCipherSuite[[:space:]]'; then
		return 0
	fi

	write_slapd_conf "$SLAPD_CONF" 's|^(TLSCipherSuite\s+)|#$1|i'
	return 1
}
# }}}

compute_backup_path() {							# {{{
# Compute the path to backup a database directory
# Usage: compute_backup_path [-n] <dir> <basedn>

# XXX: should ask the user via debconf

	local dirname basedn ok_exists
	if [ "$1" = "-n" ]; then
		ok_exists=yes
		shift
	fi
	dirname="$1"
	basedn="$2"

	# Computing the name of the backup directory from the old version, 
	# the suffix etc. all makes me feel worried. I'd rather have a 
	# directory name which is not going to exist. So the simple 
	# scheme we are using now is to compute the filename from the 
	# directory name and appending date and time. And we check if it
	# exists to be really sure...  -- Torsten

	local target
	local id
	id="$OLD_VERSION"
	[ -n "$id" ] || id=`date +%Y%m%d-%H%M%S`
	target="/var/backups/$basedn-$id.ldapdb"
	if [ -e "$target" ] && [ -z "$ok_exists" ]; then
		echo >&2
		echo >&2 "  Backup path $target exists. Giving up..."
		exit 1
	fi

	echo "$target"
}

# }}}
move_old_database_away() {						# {{{
# Move the old database away if it is still there
#
# In fact this function makes sure that the database directory is empty
# and can be populated with a new database. If something is in the way
# it is moved to a backup directory if the user accepted the debconf
# option slapd/move_old_database. Otherwise we output a warning and let
# the user fix it himself.
# Usage: move_old_database_away <dbdir> [<basedn>]

	local databasedir backupdir
	databasedir="$1"
	suffix="${2:-unknown}"
	
	if [ ! -e "$databasedir" ] || is_empty_dir "$databasedir"; then
		return 0
	fi

    
	# Note that we can't just move the database dir as it might be
	# a mount point. Instead me move the content which might 
	# include mount points as well anyway, but it's much less likely.
	db_get slapd/move_old_database
	if [ "$RET" = true ]; then
		backupdir=`compute_backup_path "$databasedir" "$suffix"`
		echo -n "  - directory $suffix... " >&2
		mkdir -p "$backupdir"
		find "$databasedir" -mindepth 1 -maxdepth 1	\
			-exec mv {} "$backupdir" \;
		echo done. >&2
	else
		cat >&2 <<EOF
  There are leftover files in $databasedir. This will probably break 
  creating the initial directory. If that's the case please move away
  stuff in there and retry the configuration.
EOF
	fi
}
# }}}
manual_configuration_wanted() {						# {{{
# Check if the user wants to configure everything himself (queries debconf)
# Returns success if yes.

	db_get slapd/no_configuration
	if [ "$RET" = "true" ]; then
		return 0
	else
		return 1
	fi
}
# }}}
copy_example_DB_CONFIG() {						# {{{
# Copy an example DB_CONFIG file
# copy_example_DB_CONFIG <directory>
	local directory srcdir
	
	directory="$1"
	srcdir="/usr/share/slapd"

	if ! [ -f "${directory}/DB_CONFIG" ] && [ -d "$directory" ]; then
		cp $srcdir/DB_CONFIG "${directory}/DB_CONFIG"
	fi
}

# }}}
create_new_configuration() {						# {{{
# Create a new configuration and directory

	local basedn dc backend

	# For the domain really.argh.org we create the basedn 
	# dc=really,dc=argh,dc=org with the dc entry dc: really
	db_get slapd/domain
	local basedn="dc=`echo $RET | sed 's/^\.//; s/\./,dc=/g'`"
	dc="`echo $RET | sed 's/^\.//; s/\..*$//'`"

	db_get slapd/backend
	backend="`echo $RET|tr A-Z a-z`"

	# Looks like the following code is not needed as slapd is unconfigured
	# first and stopped at that time. So no need to stop slapd at all here.

	if [ -e "/var/lib/ldap" ] && ! is_empty_dir /var/lib/ldap; then
		echo >&2 "  Moving old database directory to /var/backups:"
		move_old_database_away /var/lib/ldap
	fi
	create_new_slapd_conf "$basedn" "$backend"
	create_ldap_directories
	create_new_directory "$basedn" "$dc"

	# Put the right permissions on this directory.
	update_permissions /var/lib/ldap

  # Now that we created the new directory we don't need the passwords in the
  # debconf database anymore. So wipe them.
  wipe_admin_pass
}
# }}}
create_new_slapd_conf() {						# {{{
# Creates a new slapd.conf for the suffix given
# Usage: create_new_slapd_conf <basedn> <backend>

	local basedn backend backendoptions checkpoint conf_new conf_template

	basedn="$1"
	backend="$2"
	checkpoint=""
	conf_template="/usr/share/slapd/slapd.conf"

	# Note that, unlike in previous versions of this script, we just
	# assume that our default database is some BerkeleyDB varient.
	# Given current upstream feelings and relative performance, this
	# appears to be a safe assumption for the forseeable future.
	conf_new=`mktemp -q ${SLAPD_CONF}.XXXXXX`
	echo -n "  Creating initial slapd configuration... " >&2
	sed <"$conf_template" >"$conf_new" \
		-e "s/@SUFFIX@/$basedn/g" \
		-e "s/@ADMIN@/cn=admin,$basedn/g" \
		-e "s/@BACKEND@/$backend/g"
	install_new_slapd_conf "$conf_new"
	echo "done." >&2

	# If /etc/ldap/schema/core.schema doesn't exist, the configuration
	# file we're about to write will be horribly broken.  Try to give the
	# user some warning rather than failing later.
	if [ ! -e /etc/ldap/schema/core.schema ]; then
		echo >&2
		cat >&2 <<-EOF
	/etc/ldap/schema/core.schema does not exist, which means the slapd
	configuration will not work.  If you have moved the schema files
	elsewhere, you will need to modify $SLAPD_CONF accordingly.
	If you deleted the schema files inadvertantly, you may need to
	purge this package and then reinstall it to restore them (be
	careful to back up your database first if necessary).

EOF
		exit 1
	fi
} 
# }}}
noisy_slapadd() {							# {{{
# Run slapadd and output the ldif file if something goes wrong.
# Usage: noisy_slapadd [options] < ldif-file
	local ldif_tmp

	ldif_tmp=`mktemp -t slapadd.XXXXXX`
	cat > "$ldif_tmp"
	if ! slapadd "$@" < "$ldif_tmp"; then
		echo >&2 "Failed to slapadd this data: "
		cat >&2  < "$ldif_tmp" 
		rm "$ldif_tmp"
		exit 1
	fi
	rm "$ldif_tmp"
} # }}}
encode_utf8() { #{{{
# Make the value utf8 encoded. Takes one argument and utf8 encode it.
# Usage: val=`encode_utf8 <value>`
  perl -e 'use Encode; print encode_utf8($ARGV[0]);' "$1"
} #}}}
create_new_directory() {						# {{{
# Create a new directory. Takes the basedn and the dc value of that entry.
# Other information is extracted from debconf.
# Usage: create_new_directory <basedn> <dc>

	local basedn dc organization adminpass
	basedn="$1"
	dc="$2"
	
  # Encode to utf8 and base64 encode the organization.
	db_get shared/organization
	organization=`encode_utf8 "$RET"`
	db_get slapd/internal/adminpw
	adminpass="$RET"
 
	echo -n "  Creating initial LDAP directory... " >&2

	cat <<-EOF | noisy_slapadd
		dn: $basedn
		objectClass: top
		objectClass: dcObject
		objectClass: organization
		o: $organization
		dc: $dc
		
		dn: cn=admin,$basedn
		objectClass: simpleSecurityObject
		objectClass: organizationalRole
		cn: admin
		description: LDAP administrator
		userPassword: {crypt}$adminpass
	EOF

	echo "done." >&2
} 
# }}}
config_migrate_backend() {						# {{{
# Changes all uses of one backend to another (like ldbm to bdb) in the 
# configuration file. This includes the moduleload, backend and database
# directives.  This function is currently unused.
# Usage: migrate_databases <old-backend> <new-backend>

	local old new
	old="$1"
	new="$2"

	write_slapd_conf "$SLAPD_CONF" "s|^(moduleload\s+)back_$old|\$1back_$new|"
	write_slapd_conf "$SLAPD_CONF" "s|^(database\s+)$old|\$1$new|"
	write_slapd_conf "$SLAPD_CONF" "s|^(backend\s+)$old|\$1$new|"
} 

# }}}
config_obsolete_schemacheck() {						# {{{
# comment out any occurences of "schemacheck" options in the config,
# as this option is obsolete with OpenLDAP 2.4
	write_slapd_conf "$SLAPD_CONF" "s|^(schemacheck\s+)|#\$1|"
}

# }}}
configure_v2_protocol_support() {					# {{{
# Adds the "allow bind_v2" directive to the configuration if the user decided
# he wants to have ldap v2 enabled.

	local new_conf

	db_get slapd/allow_ldap_v2
	if [ "$RET" != "true" ]; then return 0; fi

	# If $SLAPD_CONF is a directory, the user is using cn=config.  Assume
	# they know what they're doing.
	if [ -d "$SLAPD_CONF" ]; then return 0; fi

	echo -n "  Enabling LDAPv2 support... " >&2

	# Check if already enabled
	if read_slapd_conf < $SLAPD_CONF | \
			grep -q -E '^allow[[:space:]][^#]*bind_v2'; then
		echo "already enabled." >&2
		return 0
	fi

	# Create a temporary file for the new config
	new_conf=`mktemp -q ${SLAPD_CONF}.XXXXXX`

	# If there is an existing global allow command, add our option
	if extend_existing_allow_directive < $SLAPD_CONF > $new_conf; then
		# Succeeded
		echo -n "updated existing allow line" >&2
	else
		# That failed, so we have to add a new line for it
		echo '# Allow LDAPv2 binds' > $new_conf
		echo 'allow bind_v2' >> $new_conf
		echo >> $new_conf
		cat $SLAPD_CONF >> $new_conf
		echo -n "done" >&2
	fi

	# Activate the new configuration file
	install_new_slapd_conf "$new_conf"
	echo . >&2
}
# }}}
extend_existing_allow_directive() {					# {{{
# Filter the config file for an allow directive and add "bind_v2" to it
# if found.

	local script
	script='
		$done = 0;
		while (<>) {
			$done = 1 if s/^allow/allow bind_v2/;
			last if m/^database/;
			print;
		}
		exit ! $done;'

	perl -e "$script" || return 1
}
# }}}
assign_permissions() {							# {{{
# Apply the same permissions as on a reference file to another file. 
# Usage: apply_permissions <original> <new>

	chmod --reference="$1" "$2"
	chown --reference="$1" "$2"
}
# }}}
install_new_slapd_conf() {						# {{{
# Installs a given file as new slapd.conf configuration file. 
# Usage: install_new_slapd_conf <newfile>

	local conf_new
	conf_new="$1"

	# On install and remove we don't have to backup the configuration
	# file. Only on upgrade.
	if [ "$MODE" = "upgrade" ]; then
		backup_config_once
	fi

	# Make sure we keep the permissions of an old slapd.conf
	if [ -e "$SLAPD_CONF" ]; then
		assign_permissions "$SLAPD_CONF" "$conf_new"
	elif [ -n "$SLAPD_GROUP" ] ; then
		chgrp "$SLAPD_GROUP" "$conf_new"
		chmod 640 "$conf_new"
	fi
	mv "$conf_new" "$SLAPD_CONF"
}
# }}}
backup_config_once() {							# {{{
# Create a backup of the current configuration files. 
# Usage: backup_config_once

	local backupdir

	if [ -z "$FLAG_CONFIG_BACKED_UP" ]; then
		backupdir=`database_dumping_destdir`
		if [ -e "$SLAPD_CONF" ]; then
			cp -a "$SLAPD_CONF" "$backupdir"
		fi
		FLAG_CONFIG_BACKED_UP=yes
	fi
}

# }}}


# Set up the defaults for our templates
set_defaults_for_unseen_entries() {
	DOMAIN=`hostname -d 2>/dev/null` || true
	if [ -z "$DOMAIN" ]; then DOMAIN='nodomain'; fi

	db_fget slapd/domain seen
	if [ "$RET" = false ]; then
		db_set slapd/domain "$DOMAIN"
	fi

	db_fget shared/organization seen
	if [ "$RET" = false ]; then
		db_set shared/organization "$DOMAIN"
	fi
}

crypt_admin_pass() {							# {{{
# Store the encrypted admin password into the debconf db
# Usage: crypt_admin_pass
# XXX: This is the standard unix crypt. Maybe we can get something stronger?

  	db_get slapd/password1
    if [ ! -z "$RET" ]; then
      db_set slapd/internal/adminpw `create_password_hash "$RET"`
    fi
}

wipe_admin_pass() {
# Remove passwords after creating the initial ldap database.
# Usage: wipe_admin_pass
    db_set slapd/password1 ""
    db_set slapd/password2 ""
    db_set slapd/internal/adminpw ""
}

# }}}
create_password_hash() {						# {{{
# Create the password hash for the given password
# Usage: hash=`create_password_hash "$password"`

  	perl - "$1" <<'EOF'
# ---------------
sub GenRandom {
	local ($len) = @_;
      	local ($char, $data, @chars);
      	@chars = split(//, "abcdefghijklmnopqrstuvwxyz"
                         . "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789");
    
      	open(RD, "</dev/urandom") or die "Failed to open random source";
      	$data = "";
      	while ($len--) {
        	read(RD, $char, 1) == 1 or die "Failed to read random data";
		$data .= $chars[ord($char) % @chars];
      	}
    
      	close(RD);
      	return $data;
}
print crypt($ARGV[0], GenRandom(2));
EOF
# --------------
}

# }}}
previous_version_older() {						# {{{
# Check if the previous version is newer than the reference version passed.
# If we are not upgrading the previous version is assumed to be newer than
# any reference version.
# Usage: previous_version_older <package version>
	
	if dpkg --compare-versions "$OLD_VERSION" lt-nl "$1"; then
		return 0
	else
		return 1
	fi
} 

# }}}
previous_version_newer() {						# {{{
# Check if the previous version is newer than the reference version passed.
# If we are not upgrading the previous version is assumed to be newer than
# any reference version.
# Usage: previous_version_newer <package version>
	
	if dpkg --compare-versions "$OLD_VERSION" gt-nl "$1"; then
		return 0
	else
		return 1
	fi
} # }}}
upgrade_supported_from_backend() {					# {{{
# Check if upgrading a database in the named backend is supported by
# our scripts.
# Usage: if upgrade_supported_from_backend "backend"; then ... fi

	case "$1" in bdb|hdb) return 0; esac
	return 1
}

# }}}
is_initial_configuration() {						# {{{
# Check if this is the initial configuration and not an upgrade of an 
# existing configuration
# Usage: if is_initial_configuration "$@"; then ... fi from top level

	# Plain installation
	if [ "$1" = configure ] && [ -z "$2" ]; then
		return 0
  	fi
	# Configuration via dpkg-reconfigure
	if [ "$1" = reconfigure ] || [ "$DEBCONF_RECONFIGURE" ]; then
    		return 0
  	fi
	# Upgrade but slapd.conf doesn't exist.  If the user is doing this
	# intentionally because they want to put it somewhere else, they
	# should select manual configuration in debconf.
	if [ "$1" = configure ] && [ ! -e "$SLAPD_CONF" ]; then
		return 0
	fi
  	return 1
}

# }}}
is_empty_dir() {							# {{{
# Check if a path refers to an empty directory
# Usage: if is_empty_dir "$dir"; then ... fi

	output=`find "$1" -type d -maxdepth 0 -empty 2>/dev/null`
  	if [ "$output" ]; then
    		return 0
  	else
    		return 1
  	fi
}

# }}}

# ===== Global variables ================================================ {{{
#
# At some points we need to know which version we are upgrading from if
# any. More precisely we only care about the configuration and data we 
# might have laying around. Some parts also want to know which mode the
# script is running in.

MODE="$1"		# install, upgrade, etc. - see debian-policy
OLD_VERSION="$2"

# Source the init script configuration
# See example file debian/slapd.default for variables defined here
if [ -f "/etc/default/slapd" ]; then
  	. /etc/default/slapd
fi

# Load the default location of the slapd config file
if [ -z "$SLAPD_CONF" ]; then
  	SLAPD_CONF="/etc/ldap/slapd.conf"
fi

# }}}

# ----- Handling diagnostic output ------------------------------------ {{{
#
# Often you want to run a program while you are showing progress 
# information to the user. If the program you are running outputs some 
# diagnostics it will mess up your screen. 
#
# This is what the following functions are designed for. When running the
# program, use capture_diagnostics to store what the program outputs to 
# stderr and use release_diagnostics to write out the captured output.


capture_diagnostics() {							# {{{
# Run the command passed and capture the diagnostic output in a temporary
# file. You can dump that file using release_diagnostics.

	# Create the temporary file
	local tmpfile
	tmpfile=`mktemp`
	exec 7<>"$tmpfile"
	rm "$tmpfile"

	# Run the program and capture stderr. If the program fails the 
	# function fails with the same status.
	"$@" 2>&7 || return $?
}

# }}}
release_diagnostics() {							# {{{
# Dump the diagnostic output captured via capture_diagnostics, optionally
# prefixing each line.
# Usage: release_diagnostics "prefix"

	local script
	script='
		seek STDIN, 0, 0;
		print "$ARGV[0]$_" while (<STDIN>);';
	perl -e "$script" "$1" <&7
}

# }}}


# }}}

# vim: set sw=8 foldmethod=marker: 

