Howard's fixes for ITS #3201.

diff -ur servers/slapd/back-bdb/back-bdb.h servers/slapd/back-bdb/back-bdb.h
--- servers/slapd/back-bdb/back-bdb.h	2004-01-01 13:16:35.000000000 -0500
+++ servers/slapd/back-bdb/back-bdb.h	2005-04-19 16:50:00.270221061 -0400
@@ -92,7 +92,9 @@
 	struct bdb_entry_info *bei_parent;
 	ID bei_id;
 
+	char bei_lockpad;
+
 	int bei_state;
 #define	CACHE_ENTRY_DELETED	1
 #define	CACHE_ENTRY_NO_KIDS	2
 #define	CACHE_ENTRY_NOT_LINKED	4
@@ -129,6 +131,7 @@
 	EntryInfo	*c_lrutail;	/* lru - rem lru entries from here */
 	ldap_pvt_thread_rdwr_t c_rwlock;
 	ldap_pvt_thread_mutex_t lru_mutex;
+	u_int32_t	c_locker;
 } Cache;
  
 #define CACHE_READ_LOCK                0
diff -ur servers/slapd/back-bdb/cache.c servers/slapd/back-bdb/cache.c
--- servers/slapd/back-bdb/cache.c	2004-01-01 13:16:35.000000000 -0500
+++ servers/slapd/back-bdb/cache.c	2005-04-19 16:42:39.508611170 -0400
@@ -74,8 +74,8 @@
 
 	if ( !lock ) return 0;
 
-	lockobj.data = ei;
-	lockobj.size = sizeof(ei->bei_parent) + sizeof(ei->bei_id);
+	lockobj.data = &ei->bei_id;
+	lockobj.size = sizeof(ei->bei_id) + 1;
 
 	list[0].op = DB_LOCK_PUT;
 	list[0].lock = *lock;
@@ -121,8 +121,8 @@
 	else
 		db_rw = DB_LOCK_READ;
 
-	lockobj.data = ei;
-	lockobj.size = sizeof(ei->bei_parent) + sizeof(ei->bei_id);
+	lockobj.data = &ei->bei_id;
+	lockobj.size = sizeof(ei->bei_id) + 1;
 
 	rc = LOCK_GET(env, locker, tryOnly ? DB_LOCK_NOWAIT : 0,
 					&lockobj, db_rw, lock);
@@ -522,7 +522,7 @@
 			/* If we can successfully writelock it, then
 			 * the object is idle.
 			 */
-			if ( bdb_cache_entry_db_lock( bdb->bi_dbenv, locker, elru, 1, 1,
+			if ( bdb_cache_entry_db_lock( bdb->bi_dbenv, bdb->bi_cache.c_locker, elru, 1, 1,
 				lockp ) == 0 ) {
 				/* If there's no entry, or this node is in
 				 * the process of linking into the cache,
@@ -645,45 +645,53 @@
 		if ( (*eip)->bei_state & CACHE_ENTRY_DELETED ) {
 			rc = DB_NOTFOUND;
 		} else {
-			bdb_cache_entry_db_lock( bdb->bi_dbenv, locker, *eip, 0, 0, lock );
-			if ( !(*eip)->bei_e ) {
-				if (!ep) {
-					rc = bdb_id2entry( op->o_bd, tid, id, &ep );
-				}
-				if ( rc == 0 ) {
-					bdb_cache_entry_db_relock( bdb->bi_dbenv, locker,
-						*eip, 1, 0, lock );
-					/* Make sure no other modifier beat us to it */
-					if ( (*eip)->bei_e ) {
-						bdb_entry_return( ep );
-						ep = NULL;
-					} else {
-						ep->e_private = *eip;
+			rc = bdb_cache_entry_db_lock( bdb->bi_dbenv, locker, *eip, 0, 0, lock );
+			/* entry is protected now, we don't need to hold the entryinfo */
+			if ( islocked ) {
+				bdb_cache_entryinfo_unlock( *eip );
+				islocked = 0;
+			}
+			if ( rc == 0 ) {
+				if ( !(*eip)->bei_e ) {
+					if (!ep) {
+						rc = bdb_id2entry( op->o_bd, tid, id, &ep );
+					}
+					if ( rc == 0 ) {
+						bdb_cache_entry_db_relock( bdb->bi_dbenv, locker,
+							*eip, 1, 0, lock );
+						/* Make sure no other modifier beat us to it */
+						if ( (*eip)->bei_e ) {
+							bdb_entry_return( ep );
+							ep = NULL;
+						} else {
+							ep->e_private = *eip;
 #ifdef BDB_HIER
-						bdb_fix_dn( ep, 0 );
+							bdb_fix_dn( ep, 0 );
 #endif
-						(*eip)->bei_e = ep;
+							(*eip)->bei_e = ep;
+						}
+						bdb_cache_entry_db_relock( bdb->bi_dbenv, locker,
+							*eip, 0, 0, lock );
 					}
-					bdb_cache_entry_db_relock( bdb->bi_dbenv, locker,
-						*eip, 0, 0, lock );
-				}
-			} else {
-				/* If we had the entry already, this item
-				 * is on the LRU list.
-				 */
-				lru_del = 1;
+				} else {
+					/* If we had the entry already, this item
+					 * is on the LRU list.
+					 */
+					lru_del = 1;
 #ifdef BDB_HIER
-				rc = bdb_fix_dn( (*eip)->bei_e, 1 );
-				if ( rc ) {
-					bdb_cache_entry_db_relock( bdb->bi_dbenv,
-						locker, *eip, 1, 0, lock );
-					/* check again in case other modifier did it already */
-					if ( bdb_fix_dn( (*eip)->bei_e, 1 ) )
-						rc = bdb_fix_dn( (*eip)->bei_e, 2 );
-					bdb_cache_entry_db_relock( bdb->bi_dbenv,
-						locker, *eip, 0, 0, lock );
-				}
+					rc = bdb_fix_dn( (*eip)->bei_e, 1 );
+					if ( rc ) {
+						bdb_cache_entry_db_relock( bdb->bi_dbenv,
+							locker, *eip, 1, 0, lock );
+						/* check again in case other modifier did it already */
+						if ( bdb_fix_dn( (*eip)->bei_e, 1 ) )
+							rc = bdb_fix_dn( (*eip)->bei_e, 2 );
+						bdb_cache_entry_db_relock( bdb->bi_dbenv,
+							locker, *eip, 0, 0, lock );
+					}
 #endif
+				}
+
 			}
 		}
 	}
@@ -739,11 +747,23 @@
 {
 	EntryInfo *new, ei;
 	struct berval rdn = e->e_name;
+	DB_LOCK lock;
 	int rc;
 
 	ei.bei_id = e->e_id;
 	ei.bei_parent = eip;
 	ei.bei_nrdn = *nrdn;
+	ei.bei_lockpad = 0;
+
+	/* Lock this entry so that bdb_add can run to completion.
+	 * It can only fail if BDB has run out of lock resources.
+	 */
+	rc = bdb_cache_entry_db_lock( bdb->bi_dbenv, locker, &ei, 1, 0, &lock );
+	if ( rc ) {
+		bdb_cache_entryinfo_unlock( eip );
+		return rc;
+	}
+
 #ifdef BDB_HIER
 	if ( nrdn->bv_len != e->e_nname.bv_len ) {
 		char *ptr = strchr( rdn.bv_val, ',' );
@@ -1148,7 +1168,7 @@
 	DB_LOCK *lock )
 {
 	ldap_pvt_thread_rdwr_wlock( &bdb->bi_cache.c_rwlock );
-	if ( bdb_cache_entry_db_lock( bdb->bi_dbenv, locker, ei, 1, 1, lock ) == 0 )
+	if ( bdb_cache_entry_db_lock( bdb->bi_dbenv, bdb->bi_cache.c_locker, ei, 1, 1, lock ) == 0 )
 	{
 		if ( ei->bei_e && !(ei->bei_state & CACHE_ENTRY_NOT_LINKED )) {
 			LRU_DELETE( &bdb->bi_cache, ei );
diff -ur servers/slapd/back-bdb/init.c servers/slapd/back-bdb/init.c
--- servers/slapd/back-bdb/init.c	2004-04-12 14:20:13.000000000 -0400
+++ servers/slapd/back-bdb/init.c	2005-04-19 16:47:37.218951290 -0400
@@ -447,6 +447,8 @@
 		return rc;
 	}
 
+	XLOCK_ID(bdb->bi_dbenv, &bdb->bi_cache.c_locker);
+
 	/* <insert> open (and create) index databases */
 	return 0;
 }
@@ -491,6 +493,8 @@
 	}
 #endif
 
+	XLOCK_ID_FREE(bdb->bi_dbenv, bdb->bi_cache.c_locker);
+
 	return 0;
 }
 
